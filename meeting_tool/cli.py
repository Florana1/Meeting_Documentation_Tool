"""Click CLI commands and options."""

import shutil
from pathlib import Path

import click
import torch

from .config import get_huggingface_token
from .pipeline import process_meeting
from .speaker_mapping import (
    find_speaker_labels,
    parse_speaker_string,
    rename_speakers_in_text,
)


@click.group()
def cli():
    """Meeting Documentation Tool - Convert Zoom recordings to formatted meeting minutes."""
    pass


@cli.command()
@click.argument("input_file", type=click.Path(exists=True, path_type=Path))
@click.option(
    "-o", "--output",
    type=click.Path(path_type=Path),
    default=None,
    help="Output file path (default: <input>.md)",
)
@click.option(
    "-s", "--speakers",
    default=None,
    help='Speaker mapping: "SPEAKER_00=Alice,SPEAKER_01=Bob"',
)
@click.option(
    "--num-speakers",
    type=int,
    default=None,
    help="Expected number of speakers (hint for diarization)",
)
@click.option(
    "--whisper-model",
    default="small",
    show_default=True,
    help="Whisper model size (tiny, base, small, medium, large-v3)",
)
@click.option(
    "--summary",
    is_flag=True,
    default=False,
    help="Use Claude API for automatic summarization (requires ANTHROPIC_API_KEY)",
)
@click.option(
    "--no-interactive",
    is_flag=True,
    default=False,
    help="Skip interactive speaker naming",
)
@click.option(
    "--device",
    type=click.Choice(["cpu", "cuda"]),
    default=None,
    help="Device for model inference (default: auto-detect)",
)
def process(input_file, output, speakers, num_speakers, whisper_model,
            summary, no_interactive, device):
    """Process a Zoom recording into meeting minutes.

    INPUT_FILE is the path to the recording (.m4a, .mp4, or other audio format).

    By default, a prompt file is saved alongside the output so you can paste
    it into any LLM (ChatGPT, Claude, Gemini, etc.) for summarization.
    Use --summary to auto-summarize via the Claude API instead.
    """
    if device is None:
        device = "cuda" if torch.cuda.is_available() else "cpu"
        click.echo(f"Using device: {device}")

    try:
        process_meeting(
            input_path=input_file,
            output_path=output,
            speakers=speakers,
            num_speakers=num_speakers,
            whisper_model=whisper_model,
            summary=summary,
            no_interactive=no_interactive,
            device=device,
        )
    except Exception as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("markdown_file", type=click.Path(exists=True, path_type=Path))
@click.option(
    "-s", "--speakers",
    default=None,
    help='Speaker mapping: "SPEAKER_00=Alice,SPEAKER_01=Bob"',
)
def rename(markdown_file, speakers):
    """Rename speakers in an existing meeting minutes file.

    MARKDOWN_FILE is the path to the .md file generated by the process command.

    If -s is not provided, the tool will show detected speakers and prompt
    for names interactively.
    """
    content = markdown_file.read_text(encoding="utf-8")
    labels = find_speaker_labels(content)

    if not labels:
        click.echo("No speaker labels (SPEAKER_XX) found in this file.")
        return

    if speakers:
        speaker_map = parse_speaker_string(speakers)
    else:
        click.echo(f"\n  {len(labels)} speakers found: {', '.join(labels)}")
        click.echo("  (Press Enter to keep the default label)\n")
        speaker_map = {}
        for label in labels:
            name = click.prompt(f"  Name for {label}", default=label, show_default=True)
            speaker_map[label] = name

    content = rename_speakers_in_text(content, speaker_map)
    markdown_file.write_text(content, encoding="utf-8")
    click.echo(f"\nRenamed speakers in {markdown_file.name}:")
    for label, name in speaker_map.items():
        click.echo(f"  {label} -> {name}")

    # Also update the sibling .prompt.txt if it exists
    prompt_file = markdown_file.with_suffix(".prompt.txt")
    if prompt_file.exists():
        prompt_content = prompt_file.read_text(encoding="utf-8")
        prompt_content = rename_speakers_in_text(prompt_content, speaker_map)
        prompt_file.write_text(prompt_content, encoding="utf-8")
        click.echo(f"  Also updated {prompt_file.name}")


@cli.command("check-setup")
def check_setup():
    """Verify that all dependencies and configuration are in place."""
    all_ok = True

    # Check ffmpeg
    click.echo("Checking ffmpeg... ", nl=False)
    if shutil.which("ffmpeg"):
        click.echo("OK")
    else:
        click.echo("NOT FOUND - install ffmpeg and add to PATH")
        all_ok = False

    # Check CUDA
    click.echo("Checking CUDA... ", nl=False)
    if torch.cuda.is_available():
        click.echo(f"OK ({torch.cuda.get_device_name(0)})")
    else:
        click.echo("Not available (will use CPU - slower)")

    # Check HuggingFace token
    click.echo("Checking HuggingFace token... ", nl=False)
    try:
        get_huggingface_token()
        click.echo("OK")
    except ValueError as e:
        click.echo(f"MISSING - {e}")
        all_ok = False

    # Check Anthropic API key (optional)
    click.echo("Checking Anthropic API key... ", nl=False)
    try:
        from .config import get_anthropic_api_key
        get_anthropic_api_key()
        click.echo("OK (--summary flag available)")
    except ValueError:
        click.echo("Not set (optional - only needed for --summary flag)")

    click.echo()
    if all_ok:
        click.echo("All checks passed! You're ready to process meetings.")
    else:
        click.echo("Some checks failed. Fix the issues above before processing.")
